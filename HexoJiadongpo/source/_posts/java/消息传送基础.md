---
title: 消息传送基础
date: 2016-05-21 23:43:49
tags: [java,jms]
categories: [java,jms]
---
# 消息传送基础

## 消息传送模型
	JMS支持两种消息传送模型：点对点模型和发布/订阅模型。有时候，又称这些消息传送模型为消息传送域。点对点消息传送模型和发布/订阅消息传送模型经常分别缩写为p2p和Pub/Sub。

	从JMS的视角来看，消息传送客户端称为JMS客户端(JMS Client)，而消息传送系统则称为JMS提供者（JMS provider）。一个JMS应用程序是由多个JMS客户端和（通常是）一个JMS提供者所组成的业务系统。
	此外，生产消息的JMS客户端称为消息生产者（message produceer），而接收消息的JMS客户端则称为消息消费者(message consumer)。一个JMS客户端可以既是消息生产者又是消息消费者。
### 点对点模型
	点对点消息传送模型允许JMS客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息。在点对点模型中，消息生产者称为发送者（Sender），而消息消费者则称为接收者（receiver）。传统上，点对点模型是一个基于拉取(Pull)或基于轮询(polling)的消息传送模型，这种模型从队列中请求消息，而不是自动地将消息推送到客户端。点对点消息传递模型的一个突出特点就是：发送到队列的消息被一个而且仅仅一个接收者所接收，即使可能有多个接收者在一个队列中侦听同一消息时，也是如此。
	点对点消息传送模型既支持异步“即发即弃（fire and forget）”消息传送方式，又支持同步请求/应答消息传送方式。点对点消息传送模型比发布订阅模型具有更强的耦合性，发磅者通常会知道消息初如何使用，而且也会知道谁将接收该消息。举例来说，发送者可能会向一个队列发送一个证券交易订单并等待响应，响应中应包含一个交易确认码。这样一来，消息发送者就会知道消息接收者将来处理交易订单。另一个例子就是一个生成长时间运行报告的异步请求。发送者发出报告请求，而当该报告准备就绪时，就会给发送者发送一条通知消息。在这种情况下，发送者就会知道消息接收者将要处理该消息并创建报告。
	点对点模型支持负载均衡，它允许多个接收者侦听同一个队列，并以此来分配负载。JMS规范没有规定在多个接收者中间分发消息的规则，尽管某些JMS厂商已经选择实现些规则来提升负载均衡能力。点对点模型还具有其他优点，比如说，队列浏览器允许客户端在消费龅牙消息之前查看队列内容—--在发布订阅模型中，并没有这样浏览器的概念。
### 发布/订阅模型
	在发布订阅模型中，消息会被发布到一个名为主题（topic）的虚拟通道中。消息生产者称为发布者(publisher)，而消息消费者则称为订阅者（subscriber）。与点对点模型不同，使用发布订阅模型发布一个主题的消息，能够由多个订阅者所接收。有时候，也称这项技术为广播(broadcasting)消息。每个订阅者都会接收到每条消息的一个副本。总地来说，发布订阅消息传送模型基本上是一个基于推送(push)的模型，其中消息自动地向消费者广播，它们无须请求或轮询主题来获得新消息。
	发布订阅模型的去耦能力要比p2p模型更强，消息发布者通常不会意识到有多少订阅者或那些订阅者如何处理这些消息。举例来说，假定每次在Java应用程序发生异常时，向一个主题发布一条消息。发布者的责任仅仅是广播发生了一个异常。该发布者不会知道或者说通常也不关心如何使用该消息。例如，有可能是订阅者根据该异常向开发人员或支持人员发送一封电子邮件，也有可能是订阅者收集不同类型的异常数目用于生成报告，甚至是订阅者根据异常的类型，使用这个信息来通知随叫随到(on-call)的技术人员。
	在发布订阅消息传送模型内部，有多种不同类型的订阅者。非持久订阅者是临时订阅类型，它们只是在主动侦听主题时才接收消息。而另一方面，持久订阅者将接收发布的每条消息的一个副本，即便在发布消息，它们处于“离线’状态时也是如此。另外还有动态持久订阅者和受管的持久订阅者等类型。

## Rpc和异步消息传送
	RPC(Remote Procedure Call，远程过程调用)是通常用于描述分布式计算模型的术语。现在Java和.Net这两种平台都在使用这个术语。基于组件的体系结构，比如企业级JavaBean（Enterprise JavaBeans，EJB），就是建立在这个模型基础之上的。对于许多应用程序来说，基于RPC的技术已经是，并且将继续是切实可行的解决方案。不过，企业消息传送模型在特定类型的分布式应用程序中表现更为出色。在本节中，我们将讨论每种模型的优缺点。
### 紧密耦合的rpc
	紧密耦合的RPC模型最为成功的一个领域就是构建3层或n层应用程序。在这个模型中，表示层（第1层）使用RPC和中间层（第2层）的业务逻辑进行通信，访问位于后端（第3层）的数据。Sun Microsystems公司的J2EE平台和Microsoft公司的.NET平台是这种体系结构最为先进的范例。
	使用J2EE、JSP和Servlet技术的表示层，而企业级JavaBean（EJB）则是中间层。抛开平台不论，这些系统使用的核心技术是基于成为定义通信范例的RPC的中间件。
	RPC试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时，调用者将被阻塞，直到该过程完成并将控制权返回给调用者。从开发者的角度看，这种同步模型使得该系统就好像运行在一个进程当中。这些工作会依次完成，同时确保以顺序完成。RPC同步的本质特性，将客户端（进行调用的软件）和服务器（为该调用服务的软件）二者紧密耦合在一起。因为客户端已被阻塞，所以它无法继续进行工作。直到服务器做出响应为止。
	RPC紧密耦合的本质特性导致出现了相互高度依赖的系统，其中一个系统的失效会对其它系统产生立竿见影的弱化影响。例如，在J2EE中，如果期望使用企业级bean的servlet顺利工作，EJB服务器就必须正常地发挥功能。
	虽然RPC在许多场景中表现优秀，但是在系统对系统的处理过程当中，它的同步、紧密耦合等本质却是一个严重的缺陷，因为”系统对系统“有很多垂直的应用程序集成在一起。在系统对系统场景中，垂直系统之间的通信线程不仅数量众多、而且方向也是错综复杂，如下图：
 
	让我们设想一下使用紧密救命的RPC机制实现这种基础设施所面临的挑战。这些系统之间的连接管理是多对多的问题。当您身混合系统中加入另一个应用程序时，您不得不回过头来让其余所有的系统都知道它，而且，这些系统也会崩溃(crash)。它们仍然需要预定停工时间，而且对象的接口也需要升级。
	当该系统的一部分中断运行时，一切都停步。当您向一个订单输入系统添加订单时，它要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞，并一直等待，直到每个系统都处理完成订单时为止。
	
	正是的PC系统的同步、紧密耦合、相互依赖等本质特性，便得子系统中出现的故障最终会导致整个系统的失效。就像在”系统对系统“场景中那样，当RPC紧密耦合的本质特性不再适用时，消息传送机制为此提供了另一种选择方案。
### 企业消息传送
	各个子系统在可用性方面存在的问题，并不是使用面向消息的中间件所事业来的后果。消息传送机制的一个基本思想就是：规定应用程序之间的通信应该采用异步方式。将各部分连接在一些的代码会假定这是一条单身消息，它不需要立即从另一个应用程序那里得到响应。换句话说，它不必等待对这条消息的响应。这是RPC和异步消息传送之间的主要区别，而且，它对于 理解消息传送系统的优点来说至关重要。
	在一个异步消息传送系统当中，每个子系统（收款、存货等）都不存在和其他系统的耦合。它们通过消息传送服务顺进行通信，因此，某个子系统出现故障，并不会妨碍其他子系统的运行。如下图：

	在网络化系统中会出现局部故障，这是一个不可避免的事实。其中的一个系统，可能会在其连接运行期间的某个时刻，发生不可预测的故障，或者需要停机。这种现象可能会由于内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素，JMS提供了保证传送（guaranteed delivery）方式，它可以确保即便发生了局部故障，预定消费者最终也会接收到这条消息。
	保证传送使用的是一种”保存并转发（store-and-forward）”的机制，这就意味着，如果预定消费者当前并不可用，底层消息服务器就会将输入的消息写到一个持久存储器（persistent store）之中。随后，当该接收应用程序变为可用时，“保存并转发”机制会把预定消费者在不可用时错过的所有消息传送给它们。

	概括来说，JMS不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序，包括EAI、B2B和摄像头模型等。通过异步处理、“保存并转发”及“保证传送”机制，它为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布订阅功能和点对点功能，提供了集成灵活性。通过位置透明和管理控制，它提供了一种健壮的、基于服务的体系结构。而且，最重要的是，它非常易于学习和使用。
